import React, { useState, useEffect, useRef } from 'react';

const BlockBreaker = () => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('ready');
  const [lives, setLives] = useState(3);
  const [score, setScore] = useState(0);
  const [stage, setStage] = useState(1);
  
  const gameRef = useRef({
    ball: { x: 300, y: 400, dx: 3, dy: -3, radius: 8 },
    paddle: { x: 250, y: 550, width: 100, height: 15 },
    blocks: [],
    items: [],
    balls: [],
    keys: {},
    activeEffects: []
  });

  const getStageConfig = (stageNum) => {
    const baseSpeed = 2.5;
    const speedIncrease = stageNum * 0.3;
    const speed = baseSpeed + speedIncrease;
    
    return {
      speed: speed,
      rows: Math.min(3 + Math.floor(stageNum / 3), 7),
      cols: Math.min(6 + Math.floor(stageNum / 5), 10),
      paddleWidth: Math.max(100 - stageNum * 3, 60)
    };
  };

  const itemTypes = [
    { type: 'bigBall', color: '#FF6B6B', symbol: 'â—', name: 'å·¨å¤§åŒ–' },
    { type: 'smallBall', color: '#4ECDC4', symbol: 'â€¢', name: 'å°å‹åŒ–' },
    { type: 'multiBall', color: '#FFD93D', symbol: 'â—‰', name: 'åˆ†è£‚' },
    { type: 'widePaddle', color: '#95E1D3', symbol: 'â”', name: 'ãƒ¯ã‚¤ãƒ‰' },
    { type: 'slowBall', color: '#A8E6CF', symbol: 'â†“', name: 'ã‚¹ãƒ­ãƒ¼' },
    { type: 'fastBall', color: '#FF8C94', symbol: 'â†‘', name: 'åŠ é€Ÿ' }
  ];

  const initBlocks = (stageNum) => {
    const config = getStageConfig(stageNum);
    const blocks = [];
    const blockWidth = 60;
    const blockHeight = 20;
    const padding = 4;
    const totalWidth = config.cols * (blockWidth + padding);
    const offsetX = (600 - totalWidth) / 2;
    const offsetY = 40;
    
    const patterns = [
      (row, col) => true,
      (row, col) => (row + col) % 2 === 0,
      (row, col) => col % 2 === 0,
      (row, col) => row % 2 === 0,
      (row, col) => Math.abs(col - config.cols/2) <= row,
      (row, col) => Math.abs(col - config.cols/2) > row,
      (row, col) => col < config.cols/2 || row % 2 === 0,
      (row, col) => (row + col) % 3 !== 0,
    ];
    
    const pattern = patterns[(stageNum - 1) % patterns.length];
    
    for (let row = 0; row < config.rows; row++) {
      for (let col = 0; col < config.cols; col++) {
        if (pattern(row, col)) {
          blocks.push({
            x: offsetX + col * (blockWidth + padding),
            y: offsetY + row * (blockHeight + padding),
            width: blockWidth,
            height: blockHeight,
            active: true,
            color: `hsl(${(row * 30 + stageNum * 20) % 360}, 70%, 60%)`,
            hasItem: Math.random() < 0.3
          });
        }
      }
    }
    return blocks;
  };

  const createItem = (x, y) => {
    const item = itemTypes[Math.floor(Math.random() * itemTypes.length)];
    return {
      x: x,
      y: y,
      width: 30,
      height: 30,
      dy: 2,
      ...item
    };
  };

  const applyItemEffect = (game, item) => {
    switch (item.type) {
      case 'bigBall':
        game.balls.forEach(ball => {
          ball.radius = 80;
          ball.normalRadius = 80;
        });
        game.activeEffects.push({ type: 'bigBall', duration: 180 });
        break;
      case 'smallBall':
        game.balls.forEach(ball => {
          ball.radius = 5;
          ball.normalRadius = 5;
        });
        game.activeEffects.push({ type: 'smallBall', duration: 300 });
        break;
      case 'multiBall':
        const newBalls = [];
        game.balls.forEach(ball => {
          for (let i = 0; i < 2; i++) {
            newBalls.push({
              x: ball.x,
              y: ball.y,
              dx: ball.dx * (0.7 + Math.random() * 0.6) * (Math.random() > 0.5 ? 1 : -1),
              dy: ball.dy * (0.7 + Math.random() * 0.6) * (Math.random() > 0.5 ? 1 : -1),
              radius: ball.radius,
              normalRadius: ball.normalRadius || 8
            });
          }
        });
        game.balls.push(...newBalls);
        break;
      case 'widePaddle':
        game.paddle.width = Math.min(game.paddle.width + 40, 200);
        game.activeEffects.push({ type: 'widePaddle', duration: 400 });
        break;
      case 'slowBall':
        game.balls.forEach(ball => {
          ball.dx *= 0.7;
          ball.dy *= 0.7;
        });
        game.activeEffects.push({ type: 'slowBall', duration: 300 });
        break;
      case 'fastBall':
        game.balls.forEach(ball => {
          ball.dx *= 1.3;
          ball.dy *= 1.3;
        });
        game.activeEffects.push({ type: 'fastBall', duration: 300 });
        break;
    }
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameRef.current;
    
    // ã‚­ãƒ¼æ“ä½œ
    const handleKeyDown = (e) => {
      game.keys[e.key] = true;
    };
    
    const handleKeyUp = (e) => {
      game.keys[e.key] = false;
    };
    
    // ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹æ“ä½œ
    const handlePointerMove = (e) => {
      const rect = canvas.getBoundingClientRect();
      let clientX;
      
      if (e.type === 'touchmove') {
        e.preventDefault();
        clientX = e.touches[0].clientX;
      } else {
        clientX = e.clientX;
      }
      
      const x = clientX - rect.left;
      game.paddle.x = Math.max(0, Math.min(x - game.paddle.width / 2, canvas.width - game.paddle.width));
    };
    
    const handlePointerStart = (e) => {
      if (e.type === 'touchstart') {
        e.preventDefault();
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('mousemove', handlePointerMove);
    canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
    canvas.addEventListener('touchstart', handlePointerStart, { passive: false });
    
    let animationId;
    const gameLoop = () => {
      if (gameState !== 'playing') return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const config = getStageConfig(stage);
      
      // ãƒ‘ãƒ‰ãƒ«ç§»å‹•
      const paddleSpeed = 7;
      if (game.keys['ArrowLeft'] && game.paddle.x > 0) {
        game.paddle.x -= paddleSpeed;
      }
      if (game.keys['ArrowRight'] && game.paddle.x < canvas.width - game.paddle.width) {
        game.paddle.x += paddleSpeed;
      }
      
      // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ™‚é–“ç®¡ç†
      game.activeEffects = game.activeEffects.filter(effect => {
        effect.duration--;
        if (effect.duration <= 0) {
          if (effect.type === 'bigBall' || effect.type === 'smallBall') {
            game.balls.forEach(ball => {
              ball.radius = 8;
              ball.normalRadius = 8;
            });
          }
          if (effect.type === 'widePaddle') {
            game.paddle.width = config.paddleWidth;
          }
          return false;
        }
        return true;
      });
      
      // ã‚¢ã‚¤ãƒ†ãƒ ç§»å‹•
      game.items.forEach((item, idx) => {
        item.y += item.dy;
        
        // ãƒ‘ãƒ‰ãƒ«ã¨ã®è¡çª
        if (
          item.y + item.height > game.paddle.y &&
          item.y < game.paddle.y + game.paddle.height &&
          item.x + item.width > game.paddle.x &&
          item.x < game.paddle.x + game.paddle.width
        ) {
          applyItemEffect(game, item);
          game.items.splice(idx, 1);
        }
        
        // ç”»é¢å¤–
        if (item.y > canvas.height) {
          game.items.splice(idx, 1);
        }
      });
      
      // ãƒœãƒ¼ãƒ«ç§»å‹•
      game.balls.forEach((ball, ballIdx) => {
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // å£ã¨ã®è¡çª
        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
          ball.dx *= -1;
        }
        if (ball.y - ball.radius < 0) {
          ball.dy *= -1;
        }
        
        // ãƒ‘ãƒ‰ãƒ«ã¨ã®è¡çª
        if (
          ball.y + ball.radius > game.paddle.y &&
          ball.y - ball.radius < game.paddle.y + game.paddle.height &&
          ball.x > game.paddle.x &&
          ball.x < game.paddle.x + game.paddle.width
        ) {
          ball.dy = -Math.abs(ball.dy);
          const hitPos = (ball.x - game.paddle.x) / game.paddle.width;
          ball.dx = (hitPos - 0.5) * 10;
        }
        
        // ãƒ–ãƒ­ãƒƒã‚¯ã¨ã®è¡çª
        game.blocks.forEach(block => {
          if (!block.active) return;
          
          if (
            ball.x + ball.radius > block.x &&
            ball.x - ball.radius < block.x + block.width &&
            ball.y + ball.radius > block.y &&
            ball.y - ball.radius < block.y + block.height
          ) {
            ball.dy *= -1;
            block.active = false;
            setScore(s => s + (10 * stage));
            
            // ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
            if (block.hasItem) {
              game.items.push(createItem(block.x + block.width / 2 - 15, block.y));
            }
          }
        });
        
        // ãƒœãƒ¼ãƒ«ãŒä¸‹ã«è½ã¡ãŸ
        if (ball.y + ball.radius > canvas.height) {
          game.balls.splice(ballIdx, 1);
        }
      });
      
      // å…¨ãƒœãƒ¼ãƒ«æ¶ˆå¤±ãƒã‚§ãƒƒã‚¯
      if (game.balls.length === 0) {
        setLives(l => {
          const newLives = l - 1;
          if (newLives <= 0) {
            setGameState('gameover');
          } else {
            // ãƒœãƒ¼ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
            const speed = config.speed;
            game.balls = [{
              x: 300,
              y: 400,
              dx: speed,
              dy: -speed,
              radius: 8,
              normalRadius: 8
            }];
            game.items = [];
            game.activeEffects = [];
          }
          return newLives;
        });
      }
      
      // å…¨ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Šãƒã‚§ãƒƒã‚¯
      if (game.blocks.every(b => !b.active)) {
        if (stage >= 15) {
          setGameState('gameover');
        } else {
          setGameState('stageclear');
        }
      }
      
      // æç”»
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.fillText(`Stage ${stage}/15`, 10, 25);
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
      let effectY = 50;
      game.activeEffects.forEach(effect => {
        const item = itemTypes.find(i => i.type === effect.type);
        if (item) {
          ctx.fillStyle = item.color;
          ctx.font = '12px Arial';
          ctx.fillText(`${item.name} ${Math.ceil(effect.duration / 60)}ç§’`, 10, effectY);
          effectY += 18;
        }
      });
      
      // ãƒ–ãƒ­ãƒƒã‚¯
      game.blocks.forEach(block => {
        if (block.active) {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x, block.y, block.width, block.height);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1;
          ctx.strokeRect(block.x, block.y, block.width, block.height);
          
          if (block.hasItem) {
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText('?', block.x + block.width / 2, block.y + block.height / 2);
            ctx.fillText('?', block.x + block.width / 2, block.y + block.height / 2);
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
          }
        }
      });
      
      // ã‚¢ã‚¤ãƒ†ãƒ 
      game.items.forEach(item => {
        ctx.fillStyle = item.color;
        ctx.fillRect(item.x, item.y, item.width, item.height);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(item.x, item.y, item.width, item.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(item.symbol, item.x + item.width / 2, item.y + item.height / 2 + 7);
        ctx.textAlign = 'left';
      });
      
      // ãƒ‘ãƒ‰ãƒ«
      const gradient = ctx.createLinearGradient(game.paddle.x, 0, game.paddle.x + game.paddle.width, 0);
      gradient.addColorStop(0, '#3B82F6');
      gradient.addColorStop(0.5, '#60A5FA');
      gradient.addColorStop(1, '#3B82F6');
      ctx.fillStyle = gradient;
      ctx.fillRect(game.paddle.x, game.paddle.y, game.paddle.width, game.paddle.height);
      
      // ãƒœãƒ¼ãƒ«
      game.balls.forEach(ball => {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        const ballGradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
        ballGradient.addColorStop(0, '#FFF');
        ballGradient.addColorStop(0.5, '#FF6B6B');
        ballGradient.addColorStop(1, '#EF4444');
        ctx.fillStyle = ballGradient;
        ctx.fill();
        ctx.closePath();
      });
      
      animationId = requestAnimationFrame(gameLoop);
    };
    
    if (gameState === 'playing') {
      gameLoop();
    }
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      canvas.removeEventListener('mousemove', handlePointerMove);
      canvas.removeEventListener('touchmove', handlePointerMove);
      canvas.removeEventListener('touchstart', handlePointerStart);
      if (animationId) cancelAnimationFrame(animationId);
    };
  }, [gameState, stage]);
  
  const startGame = () => {
    setGameState('playing');
    setLives(3);
    setScore(0);
    setStage(1);
    initStage(1);
  };
  
  const initStage = (stageNum) => {
    const game = gameRef.current;
    const config = getStageConfig(stageNum);
    
    game.balls = [{
      x: 300,
      y: 400,
      dx: config.speed,
      dy: -config.speed,
      radius: 8,
      normalRadius: 8
    }];
    game.paddle.x = 250;
    game.paddle.width = config.paddleWidth;
    game.blocks = initBlocks(stageNum);
    game.items = [];
    game.activeEffects = [];
  };
  
  const nextStage = () => {
    const nextStageNum = stage + 1;
    setStage(nextStageNum);
    initStage(nextStageNum);
    setGameState('playing');
  };
  
  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-gray-900 to-gray-800 p-4">
      <div className="mb-4 text-white text-center">
        <h1 className="text-3xl font-bold mb-2">ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ãƒ”ãƒ³ãƒœãƒ¼ãƒ«</h1>
        <div className="flex gap-6 justify-center text-xl">
          <div>ã‚¹ãƒ†ãƒ¼ã‚¸: <span className="font-bold text-cyan-400">{stage}/15</span></div>
          <div>æ®‹æ©Ÿ: <span className="font-bold text-red-400">{lives}</span></div>
          <div>ã‚¹ã‚³ã‚¢: <span className="font-bold text-yellow-400">{score}</span></div>
        </div>
      </div>
      
      <div className="relative">
        <canvas
          ref={canvasRef}
          width={600}
          height={600}
          className="border-4 border-blue-500 bg-gray-900 shadow-2xl"
        />
        
        {gameState === 'ready' && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
            <div className="text-center text-white p-6">
              <h2 className="text-3xl font-bold mb-4">15ã‚¹ãƒ†ãƒ¼ã‚¸ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼</h2>
              <p className="mb-2">PC: çŸ¢å°ã‚­ãƒ¼ â† â†’ ã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œ</p>
              <p className="mb-2">ã‚¹ãƒãƒ›: ç”»é¢ã‚¿ãƒƒãƒã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œ</p>
              <p className="mb-2 text-sm text-gray-300">?ãƒãƒ¼ã‚¯ä»˜ããƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ãŒå‡ºç¾</p>
              <div className="text-xs text-left bg-gray-800 p-3 rounded mb-4 max-w-sm mx-auto">
                <p>â— å·¨å¤§åŒ– | â€¢ å°å‹åŒ– | â—‰ åˆ†è£‚</p>
                <p>â” ãƒ¯ã‚¤ãƒ‰ | â†“ ã‚¹ãƒ­ãƒ¼ | â†‘ åŠ é€Ÿ</p>
              </div>
              <button
                onClick={startGame}
                className="px-8 py-3 bg-blue-500 hover:bg-blue-600 rounded-lg font-bold text-lg transition shadow-lg"
              >
                ã‚²ãƒ¼ãƒ é–‹å§‹
              </button>
            </div>
          </div>
        )}
        
        {gameState === 'stageclear' && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
            <div className="text-center text-white p-6">
              <h2 className="text-3xl font-bold mb-4 text-green-400">ã‚¹ãƒ†ãƒ¼ã‚¸ {stage} ã‚¯ãƒªã‚¢ï¼</h2>
              <p className="text-xl mb-4">ã‚¹ã‚³ã‚¢: {score}</p>
              <button
                onClick={nextStage}
                className="px-8 py-3 bg-green-500 hover:bg-green-600 rounded-lg font-bold text-lg transition shadow-lg"
              >
                æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
              </button>
            </div>
          </div>
        )}
        
        {gameState === 'gameover' && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
            <div className="text-center text-white p-6">
              <h2 className="text-3xl font-bold mb-4">
                {stage >= 15 ? 'ğŸ‰ å…¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ğŸ‰' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼'}
              </h2>
              <p className="text-xl mb-2">åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸: {stage}/15</p>
              <p className="text-xl mb-4">æœ€çµ‚ã‚¹ã‚³ã‚¢: {score}</p>
              <button
                onClick={startGame}
                className="px-8 py-3 bg-blue-500 hover:bg-blue-600 rounded-lg font-bold text-lg transition shadow-lg"
              >
                ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
              </button>
            </div>
          </div>
        )}
      </div>
      
      <div className="mt-4 text-gray-400 text-sm text-center max-w-md">
        <p>PC: â† â†’ çŸ¢å°ã‚­ãƒ¼ã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œ</p>
        <p>ã‚¹ãƒãƒ›: ç”»é¢ã‚’ã‚¿ãƒƒãƒ/ã‚¹ãƒ¯ã‚¤ãƒ—ã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œ</p>
        <p>?ãƒãƒ¼ã‚¯ä»˜ããƒ–ãƒ­ãƒƒã‚¯ã‚’å£Šã™ã¨ã‚¢ã‚¤ãƒ†ãƒ ãŒè½ã¡ã¦ãã¾ã™</p>
      </div>
    </div>
  );
};

export default BlockBreaker;