<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ãƒ”ãƒ³ãƒœãƒ¼ãƒ«</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      background: linear-gradient(to bottom, #111827, #1f2937);
      min-height: 100vh;
    }
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 1rem;
    }
    .header {
      margin-bottom: 1rem;
      color: white;
      text-align: center;
    }
    .title {
      font-size: 1.875rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    .stats {
      display: flex;
      gap: 1.5rem;
      justify-content: center;
      font-size: 1.25rem;
    }
    .stat-label {
      font-weight: bold;
    }
    .stat-stage { color: #22d3ee; }
    .stat-lives { color: #f87171; }
    .stat-score { color: #fbbf24; }
    .canvas-wrapper {
      position: relative;
    }
    canvas {
      border: 4px solid #3b82f6;
      background: #111827;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.8);
    }
    .overlay-content {
      text-align: center;
      color: white;
      padding: 1.5rem;
    }
    .overlay-title {
      font-size: 1.875rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }
    .overlay-title.success {
      color: #4ade80;
    }
    .overlay-text {
      font-size: 1.25rem;
      margin-bottom: 1rem;
    }
    .overlay-text-sm {
      font-size: 0.875rem;
      color: #d1d5db;
      margin-bottom: 0.5rem;
    }
    .item-list {
      font-size: 0.75rem;
      text-align: left;
      background: #1f2937;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin: 0 auto 1rem;
      max-width: 24rem;
    }
    .item-list p {
      margin-bottom: 0.25rem;
    }
    .btn {
      padding: 0.75rem 2rem;
      font-size: 1.125rem;
      font-weight: bold;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }
    .btn:hover {
      transform: translateY(-2px);
    }
    .btn-blue {
      background: #3b82f6;
      color: white;
    }
    .btn-blue:hover {
      background: #2563eb;
    }
    .btn-green {
      background: #22c55e;
      color: white;
    }
    .btn-green:hover {
      background: #16a34a;
    }
    .footer {
      margin-top: 1rem;
      color: #9ca3af;
      font-size: 0.875rem;
      text-align: center;
      max-width: 28rem;
    }
    .footer p {
      margin-bottom: 0.25rem;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const BlockBreaker = () => {
      const { useState, useEffect, useRef } = React;
      const canvasRef = useRef(null);
      const [gameState, setGameState] = useState('ready');
      const [lives, setLives] = useState(3);
      const [score, setScore] = useState(0);
      const [stage, setStage] = useState(1);
      
      const gameRef = useRef({
        ball: { x: 300, y: 400, dx: 3, dy: -3, radius: 8 },
        paddle: { x: 250, y: 550, width: 100, height: 15 },
        blocks: [],
        items: [],
        balls: [],
        keys: {},
        activeEffects: []
      });

      const getStageConfig = (stageNum) => {
        const baseSpeed = 2.5;
        const speedIncrease = stageNum * 0.3;
        const speed = baseSpeed + speedIncrease;
        
        return {
          speed: speed,
          rows: Math.min(3 + Math.floor(stageNum / 3), 7),
          cols: Math.min(6 + Math.floor(stageNum / 5), 10),
          paddleWidth: Math.max(100 - stageNum * 3, 60)
        };
      };

      const itemTypes = [
        { type: 'bigBall', color: '#FF6B6B', symbol: 'â—', name: 'å·¨å¤§åŒ–' },
        { type: 'smallBall', color: '#4ECDC4', symbol: 'â€¢', name: 'å°å‹åŒ–' },
        { type: 'multiBall', color: '#FFD93D', symbol: 'â—‰', name: 'åˆ†è£‚' },
        { type: 'widePaddle', color: '#95E1D3', symbol: 'â”', name: 'ãƒ¯ã‚¤ãƒ‰' },
        { type: 'slowBall', color: '#A8E6CF', symbol: 'â†“', name: 'ã‚¹ãƒ­ãƒ¼' },
        { type: 'fastBall', color: '#FF8C94', symbol: 'â†‘', name: 'åŠ é€Ÿ' }
      ];

      const initBlocks = (stageNum) => {
        const config = getStageConfig(stageNum);
        const blocks = [];
        const blockWidth = 60;
        const blockHeight = 20;
        const padding = 4;
        const totalWidth = config.cols * (blockWidth + padding);
        const offsetX = (600 - totalWidth) / 2;
        const offsetY = 40;
        
        const patterns = [
          (row, col) => true,
          (row, col) => (row + col) % 2 === 0,
          (row, col) => col % 2 === 0,
          (row, col) => row % 2 === 0,
          (row, col) => Math.abs(col - config.cols/2) <= row,
          (row, col) => Math.abs(col - config.cols/2) > row,
          (row, col) => col < config.cols/2 || row % 2 === 0,
          (row, col) => (row + col) % 3 !== 0,
        ];
        
        const pattern = patterns[(stageNum - 1) % patterns.length];
        
        for (let row = 0; row < config.rows; row++) {
          for (let col = 0; col < config.cols; col++) {
            if (pattern(row, col)) {
              blocks.push({
                x: offsetX + col * (blockWidth + padding),
                y: offsetY + row * (blockHeight + padding),
                width: blockWidth,
                height: blockHeight,
                active: true,
                color: `hsl(${(row * 30 + stageNum * 20) % 360}, 70%, 60%)`,
                hasItem: Math.random() < 0.3
              });
            }
          }
        }
        return blocks;
      };

      const createItem = (x, y) => {
        const item = itemTypes[Math.floor(Math.random() * itemTypes.length)];
        return {
          x: x,
          y: y,
          width: 30,
          height: 30,
          dy: 2,
          ...item
        };
      };

      const applyItemEffect = (game, item) => {
        switch (item.type) {
          case 'bigBall':
            game.balls.forEach(ball => {
              ball.radius = 80;
              ball.normalRadius = 80;
            });
            game.activeEffects.push({ type: 'bigBall', duration: 300 });
            break;
          case 'smallBall':
            game.balls.forEach(ball => {
              ball.radius = 5;
              ball.normalRadius = 5;
            });
            game.activeEffects.push({ type: 'smallBall', duration: 300 });
            break;
          case 'multiBall':
            const newBalls = [];
            game.balls.forEach(ball => {
              for (let i = 0; i < 2; i++) {
                newBalls.push({
                  x: ball.x,
                  y: ball.y,
                  dx: ball.dx * (0.7 + Math.random() * 0.6) * (Math.random() > 0.5 ? 1 : -1),
                  dy: ball.dy * (0.7 + Math.random() * 0.6) * (Math.random() > 0.5 ? 1 : -1),
                  radius: ball.radius,
                  normalRadius: ball.normalRadius || 8
                });
              }
            });
            game.balls.push(...newBalls);
            break;
          case 'widePaddle':
            game.paddle.width = Math.min(game.paddle.width + 40, 200);
            game.activeEffects.push({ type: 'widePaddle', duration: 400 });
            break;
          case 'slowBall':
            game.balls.forEach(ball => {
              ball.dx *= 0.7;
              ball.dy *= 0.7;
            });
            game.activeEffects.push({ type: 'slowBall', duration: 300 });
            break;
          case 'fastBall':
            game.balls.forEach(ball => {
              ball.dx *= 1.3;
              ball.dy *= 1.3;
            });
            game.activeEffects.push({ type: 'fastBall', duration: 300 });
            break;
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const game = gameRef.current;
        
        const handleKeyDown = (e) => {
          game.keys[e.key] = true;
        };
        
        const handleKeyUp = (e) => {
          game.keys[e.key] = false;
        };
        
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        
        let animationId;
        const gameLoop = () => {
          if (gameState !== 'playing') return;
          
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          const config = getStageConfig(stage);
          
          const paddleSpeed = 7;
          if (game.keys['ArrowLeft'] && game.paddle.x > 0) {
            game.paddle.x -= paddleSpeed;
          }
          if (game.keys['ArrowRight'] && game.paddle.x < canvas.width - game.paddle.width) {
            game.paddle.x += paddleSpeed;
          }
          
          game.activeEffects = game.activeEffects.filter(effect => {
            effect.duration--;
            if (effect.duration <= 0) {
              if (effect.type === 'bigBall' || effect.type === 'smallBall') {
                game.balls.forEach(ball => {
                  ball.radius = 8;
                  ball.normalRadius = 8;
                });
              }
              if (effect.type === 'widePaddle') {
                game.paddle.width = config.paddleWidth;
              }
              return false;
            }
            return true;
          });
          
          game.items.forEach((item, idx) => {
            item.y += item.dy;
            
            if (
              item.y + item.height > game.paddle.y &&
              item.y < game.paddle.y + game.paddle.height &&
              item.x + item.width > game.paddle.x &&
              item.x < game.paddle.x + game.paddle.width
            ) {
              applyItemEffect(game, item);
              game.items.splice(idx, 1);
            }
            
            if (item.y > canvas.height) {
              game.items.splice(idx, 1);
            }
          });
          
          game.balls.forEach((ball, ballIdx) => {
            ball.x += ball.dx;
            ball.y += ball.dy;
            
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
              ball.dx *= -1;
            }
            if (ball.y - ball.radius < 0) {
              ball.dy *= -1;
            }
            
            if (
              ball.y + ball.radius > game.paddle.y &&
              ball.y - ball.radius < game.paddle.y + game.paddle.height &&
              ball.x > game.paddle.x &&
              ball.x < game.paddle.x + game.paddle.width
            ) {
              ball.dy = -Math.abs(ball.dy);
              const hitPos = (ball.x - game.paddle.x) / game.paddle.width;
              ball.dx = (hitPos - 0.5) * 10;
            }
            
            game.blocks.forEach(block => {
              if (!block.active) return;
              
              if (
                ball.x + ball.radius > block.x &&
                ball.x - ball.radius < block.x + block.width &&
                ball.y + ball.radius > block.y &&
                ball.y - ball.radius < block.y + block.height
              ) {
                ball.dy *= -1;
                block.active = false;
                setScore(s => s + (10 * stage));
                
                if (block.hasItem) {
                  game.items.push(createItem(block.x + block.width / 2 - 15, block.y));
                }
              }
            });
            
            if (ball.y + ball.radius > canvas.height) {
              game.balls.splice(ballIdx, 1);
            }
          });
          
          if (game.balls.length === 0) {
            setLives(l => {
              const newLives = l - 1;
              if (newLives <= 0) {
                setGameState('gameover');
              } else {
                const speed = config.speed;
                game.balls = [{
                  x: 300,
                  y: 400,
                  dx: speed,
                  dy: -speed,
                  radius: 8,
                  normalRadius: 8
                }];
                game.items = [];
                game.activeEffects = [];
              }
              return newLives;
            });
          }
          
          if (game.blocks.every(b => !b.active)) {
            if (stage >= 15) {
              setGameState('gameover');
            } else {
              setGameState('stageclear');
            }
          }
          
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.fillText(`Stage ${stage}/15`, 10, 25);
          
          let effectY = 50;
          game.activeEffects.forEach(effect => {
            const item = itemTypes.find(i => i.type === effect.type);
            if (item) {
              ctx.fillStyle = item.color;
              ctx.font = '12px Arial';
              ctx.fillText(`${item.name} ${Math.ceil(effect.duration / 60)}ç§’`, 10, effectY);
              effectY += 18;
            }
          });
          
          game.blocks.forEach(block => {
            if (block.active) {
              ctx.fillStyle = block.color;
              ctx.fillRect(block.x, block.y, block.width, block.height);
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 1;
              ctx.strokeRect(block.x, block.y, block.width, block.height);
              
              if (block.hasItem) {
                ctx.fillStyle = '#FFD700';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText('?', block.x + block.width / 2, block.y + block.height / 2);
                ctx.fillText('?', block.x + block.width / 2, block.y + block.height / 2);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
              }
            }
          });
          
          game.items.forEach(item => {
            ctx.fillStyle = item.color;
            ctx.fillRect(item.x, item.y, item.width, item.height);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(item.x, item.y, item.width, item.height);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.symbol, item.x + item.width / 2, item.y + item.height / 2 + 7);
            ctx.textAlign = 'left';
          });
          
          const gradient = ctx.createLinearGradient(game.paddle.x, 0, game.paddle.x + game.paddle.width, 0);
          gradient.addColorStop(0, '#3B82F6');
          gradient.addColorStop(0.5, '#60A5FA');
          gradient.addColorStop(1, '#3B82F6');
          ctx.fillStyle = gradient;
          ctx.fillRect(game.paddle.x, game.paddle.y, game.paddle.width, game.paddle.height);
          
          game.balls.forEach(ball => {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            const ballGradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
            ballGradient.addColorStop(0, '#FFF');
            ballGradient.addColorStop(0.5, '#FF6B6B');
            ballGradient.addColorStop(1, '#EF4444');
            ctx.fillStyle = ballGradient;
            ctx.fill();
            ctx.closePath();
          });
          
          animationId = requestAnimationFrame(gameLoop);
        };
        
        if (gameState === 'playing') {
          gameLoop();
        }
        
        return () => {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
          if (animationId) cancelAnimationFrame(animationId);
        };
      }, [gameState, stage]);
      
      const startGame = () => {
        setGameState('playing');
        setLives(3);
        setScore(0);
        setStage(1);
        initStage(1);
      };
      
      const initStage = (stageNum) => {
        const game = gameRef.current;
        const config = getStageConfig(stageNum);
        
        game.balls = [{
          x: 300,
          y: 400,
          dx: config.speed,
          dy: -config.speed,
          radius: 8,
          normalRadius: 8
        }];
        game.paddle.x = 250;
        game.paddle.width = config.paddleWidth;
        game.blocks = initBlocks(stageNum);
        game.items = [];
        game.activeEffects = [];
      };
      
      const nextStage = () => {
        const nextStageNum = stage + 1;
        setStage(nextStageNum);
        initStage(nextStageNum);
        setGameState('playing');
      };
      
      return (
        <div className="container">
          <div className="header">
            <h1 className="title">ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ãƒ”ãƒ³ãƒœãƒ¼ãƒ«</h1>
            <div className="stats">
              <div>ã‚¹ãƒ†ãƒ¼ã‚¸: <span className="stat-label stat-stage">{stage}/15</span></div>
              <div>æ®‹æ©Ÿ: <span className="stat-label stat-lives">{lives}</span></div>
              <div>ã‚¹ã‚³ã‚¢: <span className="stat-label stat-score">{score}</span></div>
            </div>
          </div>
          
          <div className="canvas-wrapper">
            <canvas
              ref={canvasRef}
              width={600}
              height={600}
            />
            
            {gameState === 'ready' && (
              <div className="overlay">
                <div className="overlay-content">
                  <h2 className="overlay-title">15ã‚¹ãƒ†ãƒ¼ã‚¸ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼</h2>
                  <p className="overlay-text-sm">çŸ¢å°ã‚­ãƒ¼ â† â†’ ã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œ</p>
                  <p className="overlay-text-sm">?ãƒãƒ¼ã‚¯ä»˜ããƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ãŒå‡ºç¾</p>
                  <div className="item-list">
                    <p>â— å·¨å¤§åŒ– | â€¢ å°å‹åŒ– | â—‰ åˆ†è£‚</p>
                    <p>â” ãƒ¯ã‚¤ãƒ‰ | â†“ ã‚¹ãƒ­ãƒ¼ | â†‘ åŠ é€Ÿ</p>
                  </div>
                  <button onClick={startGame} className="btn btn-blue">
                    ã‚²ãƒ¼ãƒ é–‹å§‹
                  </button>
                </div>
              </div>
            )}
            
            {gameState === 'stageclear' && (
              <div className="overlay">
                <div className="overlay-content">
                  <h2 className="overlay-title success">ã‚¹ãƒ†ãƒ¼ã‚¸ {stage} ã‚¯ãƒªã‚¢ï¼</h2>
                  <p className="overlay-text">ã‚¹ã‚³ã‚¢: {score}</p>
                  <button onClick={nextStage} className="btn btn-green">
                    æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
                  </button>
                </div>
              </div>
            )}
            
            {gameState === 'gameover' && (
              <div className="overlay">
                <div className="overlay-content">
                  <h2 className="overlay-title">
                    {stage >= 15 ? 'ğŸ‰ å…¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ğŸ‰' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼'}
                  </h2>
                  <p className="overlay-text">åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸: {stage}/15</p>
                  <p className="overlay-text">æœ€çµ‚ã‚¹ã‚³ã‚¢: {score}</p>
                  <button onClick={startGame} className="btn btn-blue">
                    ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
                  </button>
                </div>
              </div>
            )}
          </div>
          
          <div className="footer">
            <p>â† â†’ çŸ¢å°ã‚­ãƒ¼ã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œã—ã¦ãƒœãƒ¼ãƒ«ã‚’è·³ã­è¿”ãã†ï¼</p>
            <p>?ãƒãƒ¼ã‚¯ä»˜ããƒ–ãƒ­ãƒƒã‚¯ã‚’å£Šã™ã¨ã‚¢ã‚¤ãƒ†ãƒ ãŒè½ã¡ã¦ãã¾ã™</p>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<BlockBreaker />);
  </script>
</body>
</html>
